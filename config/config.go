// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package config

import "encoding/json"
import "fmt"

type LoggingEncoderConfig struct {
	// LevelEncoder corresponds to the JSON schema field "levelEncoder".
	LevelEncoder string `json:"levelEncoder,omitempty"`

	// LevelKey corresponds to the JSON schema field "levelKey".
	LevelKey string `json:"levelKey,omitempty"`

	// MessageKey corresponds to the JSON schema field "messageKey".
	MessageKey string `json:"messageKey,omitempty"`

	// TimeEncoder corresponds to the JSON schema field "timeEncoder".
	TimeEncoder string `json:"timeEncoder,omitempty"`

	// TimeKey corresponds to the JSON schema field "timeKey".
	TimeKey string `json:"timeKey,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LoggingEncoderConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain LoggingEncoderConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["levelEncoder"]; !ok || v == nil {
		plain.LevelEncoder = "uppercase"
	}
	if v, ok := raw["levelKey"]; !ok || v == nil {
		plain.LevelKey = "level"
	}
	if v, ok := raw["messageKey"]; !ok || v == nil {
		plain.MessageKey = "message"
	}
	if v, ok := raw["timeEncoder"]; !ok || v == nil {
		plain.TimeEncoder = "iso8601"
	}
	if v, ok := raw["timeKey"]; !ok || v == nil {
		plain.TimeKey = "time"
	}
	*j = LoggingEncoderConfig(plain)
	return nil
}

type Logging struct {
	// Development corresponds to the JSON schema field "development".
	Development bool `json:"development,omitempty"`

	// EncoderConfig corresponds to the JSON schema field "encoderConfig".
	EncoderConfig *LoggingEncoderConfig `json:"encoderConfig,omitempty"`

	// Encoding corresponds to the JSON schema field "encoding".
	Encoding string `json:"encoding,omitempty"`

	// ErrorOutputPaths corresponds to the JSON schema field "errorOutputPaths".
	ErrorOutputPaths []string `json:"errorOutputPaths,omitempty"`

	// Level corresponds to the JSON schema field "level".
	Level string `json:"level,omitempty"`

	// OutputPaths corresponds to the JSON schema field "outputPaths".
	OutputPaths []string `json:"outputPaths,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Logging) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Logging
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["development"]; !ok || v == nil {
		plain.Development = false
	}
	if v, ok := raw["encoding"]; !ok || v == nil {
		plain.Encoding = "json"
	}
	if v, ok := raw["level"]; !ok || v == nil {
		plain.Level = "info"
	}
	*j = Logging(plain)
	return nil
}

type Opa struct {
	// Enabled corresponds to the JSON schema field "enabled".
	Enabled bool `json:"enabled,omitempty"`

	// LoadLibPath corresponds to the JSON schema field "load_lib_path".
	LoadLibPath *string `json:"load_lib_path,omitempty"`

	// NativeLibPath corresponds to the JSON schema field "native_lib_path".
	NativeLibPath *string `json:"native_lib_path,omitempty"`

	// PollingPeriod corresponds to the JSON schema field "polling_period".
	PollingPeriod int `json:"polling_period,omitempty"`

	// Server corresponds to the JSON schema field "server".
	Server string `json:"server,omitempty"`

	// SkipVerify corresponds to the JSON schema field "skip_verify".
	SkipVerify bool `json:"skip_verify,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Opa) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Opa
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["enabled"]; !ok || v == nil {
		plain.Enabled = false
	}
	if v, ok := raw["polling_period"]; !ok || v == nil {
		plain.PollingPeriod = 30
	}
	if v, ok := raw["server"]; !ok || v == nil {
		plain.Server = "http://opa.traceableai:8181/"
	}
	if v, ok := raw["skip_verify"]; !ok || v == nil {
		plain.SkipVerify = false
	}
	*j = Opa(plain)
	return nil
}

type ReportingProxy struct {
	// Host corresponds to the JSON schema field "host".
	Host string `json:"host"`

	// Password corresponds to the JSON schema field "password".
	Password *string `json:"password,omitempty"`

	// Port corresponds to the JSON schema field "port".
	Port int `json:"port"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ReportingProxy) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["host"]; !ok || v == nil {
		return fmt.Errorf("field host: required")
	}
	if v, ok := raw["port"]; !ok || v == nil {
		return fmt.Errorf("field port: required")
	}
	type Plain ReportingProxy
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ReportingProxy(plain)
	return nil
}

type Reporting struct {
	// Address corresponds to the JSON schema field "address".
	Address string `json:"address,omitempty"`

	// ApiKey corresponds to the JSON schema field "api_key".
	ApiKey *string `json:"api_key,omitempty"`

	// BackoffDelayMs corresponds to the JSON schema field "backoff_delay_ms".
	BackoffDelayMs int `json:"backoff_delay_ms,omitempty"`

	// ConfigAddress corresponds to the JSON schema field "config_address".
	ConfigAddress *string `json:"config_address,omitempty"`

	// EventsAddress corresponds to the JSON schema field "events_address".
	EventsAddress *string `json:"events_address,omitempty"`

	// IamAddress corresponds to the JSON schema field "iam_address".
	IamAddress *string `json:"iam_address,omitempty"`

	// MetricsAddress corresponds to the JSON schema field "metrics_address".
	MetricsAddress *string `json:"metrics_address,omitempty"`

	// Proxy corresponds to the JSON schema field "proxy".
	Proxy *ReportingProxy `json:"proxy,omitempty"`

	// QueueSize corresponds to the JSON schema field "queue_size".
	QueueSize int `json:"queue_size,omitempty"`

	// RetryOnFailure corresponds to the JSON schema field "retry_on_failure".
	RetryOnFailure bool `json:"retry_on_failure,omitempty"`

	// Tls corresponds to the JSON schema field "tls".
	Tls bool `json:"tls,omitempty"`

	// Token corresponds to the JSON schema field "token".
	Token *string `json:"token,omitempty"`

	// TracesAddress corresponds to the JSON schema field "traces_address".
	TracesAddress *string `json:"traces_address,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Reporting) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Reporting
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["address"]; !ok || v == nil {
		plain.Address = "api.traceable.ai"
	}
	if v, ok := raw["backoff_delay_ms"]; !ok || v == nil {
		plain.BackoffDelayMs = 3000
	}
	if v, ok := raw["queue_size"]; !ok || v == nil {
		plain.QueueSize = 100
	}
	if v, ok := raw["retry_on_failure"]; !ok || v == nil {
		plain.RetryOnFailure = true
	}
	if v, ok := raw["tls"]; !ok || v == nil {
		plain.Tls = true
	}
	*j = Reporting(plain)
	return nil
}
